---
published: true
title: "Practical Papers: Chord, A Scalable Peer-To-Peer Lookup Protocol"
date: 2020-01-28T00:00:00.000Z
categories: ["project"]
tags: ["distributed-systems", "golang", "dht"]
---

Chord is one of the original Distributed Hash Table projects from the MIT PDOS group at Computer Science and AI Laboratory, MIT. [Here](https://pdos.csail.mit.edu/papers/chord:sigcomm01/chord_sigcomm.pdf) is a link to the original research for your reading pleasure. I was introduced to Chord by the book [Distributed Systems by Maarten van Steen and Andrew S. Tanenbaum](https://www.distributed-systems.net/) (p. 246, p. 248) as a solution for implementing a decentralized naming system or a structured decentralized overlay network.

## Whats a Distributed Hash Table?

* A Hash Table is a data structure which stores values associated with keys and allows direct access to the values using these associated keys. A Hash Table is called a Dictionary in Python and Map in Golang.

A distributed hash table, a DHT is a hash table distributed across various nodes in the network. The system allows any node that is part of the network to lookup location (i.e IP Address, in most cases) of the node containing the value of the key (not the value of the key itself).

PS. A node is just a system running the DHT program that is part of the DHT network.

## How Chord creates a DHT?

[Chord](https://pdos.csail.mit.edu/papers/chord:sigcomm01/chord_sigcomm.pdf) was introduced in 2001 as one of the four original DHT protocols (CAN, Tapestry, Pastry, and Chord). This post will only focus on Chord (mostly because I haven't read about the other protocols, yet).

Chord suggests creating a Ring shaped overlay network in which nodes are arranged based on a unique numeric ID computed on the node. This ID is generated by using a Hash function which computes a integer from the passed in bytestream, in this case the hostname of the node. Every node in the system has an integer value associated with it which can be compared with each other, thus the Chord ring can be created by arranging them in increasing order of value of this ID. This ID stay's consistent throughout lifetime of the system unless the network interface is changed.

Let there be 4 nodes: n1, n2, n3, n4 with ID's 100, 200, 300, 400 respectively and arrange them in a Ring overlay. 
```
    n1 ---------- n2 
  (100)          (200)
    |              |
    |              |
    |              |
    n4 ---------- n3
  (400)          (300)
```

The Hash function is the SHA1 Hash of a bytestream and from this 160bit hash a fixed amount of bits are extracted to create a numeric value, in our case it is 64bits to create a 64 bit unsigned integer. 

```go
    // SHA1 hash of the data and extract a 64 bit (8 byte) integer out of it.
    func Hash(data []byte) {
        ID := SHA1(data)[:8]
    }
``` 

A key in the DHT who's location is to be resolved is hashed using the same hashing function as described above. Let the Key be any bytestream, example: Key = "UserData". The function Hash(Key) returns a numerical value which will lie between one of the nodes in the Chord ring.
```
        Hash(Key) = 125
           ↓
    n1 ---------- n2 
  (100)          (200)
    |              |
    |              |
    |              |
    n4 ---------- n3
  (400)          (300)
```
The most important aim of the system is to implement the function `FindSuccessor(HashedKey)` to lookup the location of a key in the DHT. If we execute `FindSuccessor(Hash(Key))` on any of the nodes that are part of the network, It will return the node's location who's ID's numerical value lies just next to the value of the hashed key value. In our case `FindSuccessor(Hash(Key))` will return the location of node n2.
```
    Hash(Key) FindSuccessor(Hash(Key))
        ↓         ↓
    n1 ---------- n2 
    |              |
    |              |  
    |              |
    n4 ---------- n3
```

The paper presents a psuedocode implementation of FindSuccessor, the concept of finger tables and how different nodes can join and leave the network.

## Functions and Structures

The paper provides pseudocode for the many functions required to implement the DHT, my implementation also follows the pseudocode as presented in the paper. The concept of a **Finger table** and **Successor table** are used to improve the efficiency of the protocol.

## TODO

- Different functions presented in the paper.
- Walkthrough of my implementation of [Chord in Golang](https://github.com/arush15june/chord-golang).
- Possible applications of chord.