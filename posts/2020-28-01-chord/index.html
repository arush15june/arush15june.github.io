<!doctype html><html lang=en><head><title>Practical Papers: Chord, A Scalable Peer-To-Peer Lookup Protocol :: silly onions — Opinionated articles</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta name=description content="The post is an explanation of the Chord protocol and discussion of my implementation of the same in Golang.  Chord is one of the original Distributed Hash Table projects from the MIT PDOS group at Computer Science and AI Laboratory, MIT. Here is a link to the original research for your reading pleasure. I was introduced to Chord by the book Distributed Systems by Maarten van Steen and Andrew S."><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=/posts/2020-28-01-chord/><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-99588570-3','auto');ga('send','pageview');}</script><link rel=stylesheet href=/assets/style.css><link rel=stylesheet href=/assets/red.css><link rel=apple-touch-icon-precomposed sizes=144x144 href=/img/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/img/favicon/red.png><meta name=twitter:card content="summary"><meta name=twitter:title content="Practical Papers: Chord, A Scalable Peer-To-Peer Lookup Protocol :: silly onions — Opinionated articles"><meta name=twitter:description content="The post is an explanation of the Chord protocol and discussion of my implementation of the same in Golang.  Chord is one of the original Distributed Hash Table projects from the MIT PDOS group at Computer Science and AI Laboratory, MIT. Here is a link to the original research for your reading pleasure. I was introduced to Chord by the book Distributed Systems by Maarten van Steen and Andrew S."><meta name=twitter:site content="/"><meta name=twitter:creator content><meta name=twitter:image content><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="Practical Papers: Chord, A Scalable Peer-To-Peer Lookup Protocol :: silly onions — Opinionated articles"><meta property="og:description" content="The post is an explanation of the Chord protocol and discussion of my implementation of the same in Golang.  Chord is one of the original Distributed Hash Table projects from the MIT PDOS group at Computer Science and AI Laboratory, MIT. Here is a link to the original research for your reading pleasure. I was introduced to Chord by the book Distributed Systems by Maarten van Steen and Andrew S."><meta property="og:url" content="/posts/2020-28-01-chord/"><meta property="og:site_name" content="Practical Papers: Chord, A Scalable Peer-To-Peer Lookup Protocol"><meta property="og:image" content><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><meta property="article:section" content="project"><meta property="article:published_time" content="2020-01-28 00:00:00 +0000 UTC"></head><body><div class="container center"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>sillyonions</div></a></div><div class=menu-trigger>menu</div></div><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/about>About</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/about>About</a></li></ul></nav></header><div class=content><div class=post><h1 class=post-title><a href=/posts/2020-28-01-chord/>Practical Papers: Chord, A Scalable Peer-To-Peer Lookup Protocol</a></h1><div class=post-meta><span class=post-date>2020-01-28</span></div><span class=post-tags>#<a href=/tags/distributed-systems/>distributed-systems</a>&nbsp;
#<a href=/tags/golang/>golang</a>&nbsp;
#<a href=/tags/dht/>dht</a>&nbsp;
#<a href=/tags/chord/>chord</a>&nbsp;</span><div class=post-content><ul><li>The post is an explanation of the Chord protocol and discussion of my <a href=https://github.com/arush15june/chord-golang>implementation</a> of the same in Golang.</li></ul><p>Chord is one of the original Distributed Hash Table projects from the MIT PDOS group at Computer Science and AI Laboratory, MIT. <a href=https://pdos.csail.mit.edu/papers/chord:sigcomm01/chord_sigcomm.pdf>Here</a> is a link to the original research for your reading pleasure. I was introduced to Chord by the book <a href=https://www.distributed-systems.net/>Distributed Systems by Maarten van Steen and Andrew S. Tanenbaum</a> (p. 246, p. 248) as a solution for implementing a decentralized naming system or a structured decentralized overlay network.</p><h2 id=whats-a-distributed-hash-table>Whats a Distributed Hash Table?</h2><ul><li>A Hash Table is a data structure which stores values associated with keys and allows direct access to the values using these associated keys. A Hash Table is called a Dictionary in Python and Map in Golang.</li></ul><p>A distributed hash table, a DHT is a hash table distributed across various nodes in the network. The system allows any node that is part of the network to lookup location (i.e IP Address, in most cases) of the node containing the value of the key (not the value of the key itself).</p><p>PS. A node is just a system running the DHT program that is part of the DHT network.</p><h2 id=how-chord-creates-a-dht>How Chord creates a DHT?</h2><p><a href=https://pdos.csail.mit.edu/papers/chord:sigcomm01/chord_sigcomm.pdf>Chord</a> was introduced in 2001 as one of the four original DHT protocols (CAN, Tapestry, Pastry, and Chord). This post will only focus on Chord (mostly because I haven&rsquo;t read about the other protocols, yet).</p><p>Chord suggests creating a Ring shaped overlay network in which nodes are arranged based on a unique numeric ID computed on the node. This ID is generated by using a Hash function which computes an integer from the passed in bytestream, in this case, the hostname of the node. Every node in the system has an integer value associated with it which can be compared with each other, thus the Chord ring can be created by arranging them in increasing order of value of this ID. This ID stays consistent throughout the lifetime of the system unless the network interface is changed.</p><p>Let there be 4 nodes: n1, n2, n3, n4 with ID&rsquo;s 100, 200, 300, 400 respectively and arrange them in a Ring overlay. n2 is the successor of n1, n3 is the successor of n2, and so on.</p><pre><code>    n1 ---------- n2 
  (100)          (200)
    |              |
    |              |
    |              |
    n4 ---------- n3
  (400)          (300)
</code></pre><p>The Hash function is the SHA1 Hash of a bytestream and from this 160bit hash, a fixed amount of bits are extracted to create a numeric value, in our case it is 64bits to create a 64-bit unsigned integer.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>    <span style=color:#75715e>// SHA1 hash of the data and extract a 64 bit (8 bytes) integer out of it.
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Hash</span>(<span style=color:#a6e22e>data</span> []<span style=color:#66d9ef>byte</span>) {
        <span style=color:#a6e22e>ID</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>SHA1</span>(<span style=color:#a6e22e>data</span>)[:<span style=color:#ae81ff>8</span>]
    }
</code></pre></div><p>A key in the DHT whose location is to be resolved is hashed using the same hashing function as described above. Let the Key be any bytestream, example: Key = &ldquo;UserData&rdquo;. The function Hash(Key) returns a numerical value which will lie between one of the nodes in the Chord ring.</p><pre><code>        Hash(Key) = 125
           ↓
    n1 ---------- n2 
  (100)          (200)
    |              |
    |              |
    |              |
    n4 ---------- n3
  (400)          (300)
</code></pre><p>The most important aim of the system is to implement the function <code>FindSuccessor(HashedKey)</code> to lookup the location of a key in the DHT. If we execute <code>FindSuccessor(Hash(Key))</code> on any of the nodes that are part of the network, It will return the node&rsquo;s location who&rsquo;s ID&rsquo;s numerical value lies just next to the value of the hashed key value. In our case <code>FindSuccessor(Hash(Key))</code> will return the location of node n2.</p><pre><code>    Hash(Key) FindSuccessor(Hash(Key))
        ↓         ↓
    n1 ---------- n2 
  (100)          (200)
    |              |
    |              |
    |              |
    n4 ---------- n3
  (400)          (300)
</code></pre><h2 id=functions-and-structures>Functions and Structures</h2><p>The paper provides pseudocode for the many functions required to implement the DHT, my implementation also follows the pseudocode as presented in the paper. The concept of a <strong>Finger table</strong> and <strong>Successor table</strong> are used to improve the efficiency of the protocol.</p><p>To increase the number of keys which converge after lookup on a single physical node, multiple <em>virtual nodes</em> can be deployed at once. Each virtual node can be contacted independently by other nodes in the network. Every node in the network stores a reference to its successor and predecessor and supports the <strong>FindSuccessor</strong> function to lookup key locations.</p><h3 id=findsuccessor>FindSuccessor</h3><p>The paper&rsquo;s pseudocode algorithm of <strong>FindSuccessor</strong> looks at the current node&rsquo;s successor&rsquo;s ID if it is the successor to the key to be looked up. If it is not, A finger table which stores references to different nodes in the network is used to find the node whose ID precedes the key, thus this node&rsquo;s successor is the successor of the key. This node is then asked to look up the key.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++>n.find_successor(id)
  <span style=color:#66d9ef>if</span> (id is between n and successor, inclusive of successor)
    <span style=color:#66d9ef>return</span> successor;
  <span style=color:#66d9ef>else</span>
    n0 <span style=color:#f92672>=</span> closest_preceding_node(id);
  <span style=color:#66d9ef>return</span> n0.find_successor(id);
</code></pre></div><p>A naive approach could be to keep asking the successor of the node to look up the key, which will trigger it to ask its own successor and so on. This is a rather inefficient solution, the finger table resolves this problem by creating a list of nodes in the network according to the formula for generating an ID: <strong>(n + 2i) mod 2m</strong>, where m is the total nodes that can be in the finger table and i goes on till m.</p><p>The paper provides proof that using the finger table every lookup request, with high probability, can be resolved by contacting O(log N) nodes, where N is the number of nodes in the network.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++>n.closest_preceding_node(id)
  <span style=color:#66d9ef>for</span> i <span style=color:#f92672>=</span> m downto <span style=color:#ae81ff>1</span>
    <span style=color:#66d9ef>if</span> (finger[i] <span style=color:#ae81ff>2</span> (n; id))
    <span style=color:#66d9ef>return</span> finger[i];
  <span style=color:#66d9ef>return</span> n;
</code></pre></div><p>A node in the Chord ring contains a reference to its successor, predecessor and a finger table which is a list of different nodes in the network.</p><h3 id=fixing-fingers>Fixing Fingers</h3><p>The finger table is created and updated over the lifetime of the node. The paper suggests the method <strong>FixFingers</strong> to periodically update fingers in the finger table. This periodical update interval to update the finger table as suggested by the paper is 15 seconds.</p><p>On every execution of <strong>FixFingers</strong>, one entry in the finger table is updated.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++>n.fix_fingers()
  next <span style=color:#f92672>=</span> next <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
  <span style=color:#66d9ef>if</span> (next <span style=color:#f92672>&gt;</span> m)
    next <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
  finger[next] <span style=color:#f92672>=</span> n.find_successor(n <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span><span style=color:#f92672>^</span>(next <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) );
</code></pre></div><h3 id=creating-a-network>Creating a Network</h3><p>If a node wants to create a Chord ring and be the first node in the network. It can set its predecessor to be nil and keep the reference of the successor to be itself.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++>n.create()
  predecessor <span style=color:#f92672>=</span> nil;
  successor <span style=color:#f92672>=</span> n;
</code></pre></div><h3 id=joining-a-network>Joining a Network</h3><p>If a node wants to join a Chord ring it needs to know the network location of at least one other node in the network and contact it by asking this node to resolve the successor for itself.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++>n.join(n1)
  predecessor <span style=color:#f92672>=</span> nil
  successor <span style=color:#f92672>=</span> n1.find_successor(n)
</code></pre></div><h3 id=dynamic-operations-and-failures>Dynamic Operations and Failures</h3><p>The network has to be dynamically updated to let nodes join the network at will and stale nodes be removed from the network and stabilize the ring again. The paper suggests a stabilization routine to regularly verify that the current successor is still its successor and no new node has joined in between them in the ring.</p><p>The <strong>Stabilize</strong> routine takes the ID of the predecessor node of its successor (Each node stores the reference of its predecessor and successor) and verifies it to be itself. If it is not, it is verified if this new node lies in between itself and successor which makes it the new successor of the node replacing the previously believed successor. This new node is also notified of its new predecessor. Thus, stabilizing this 3 node arc of the Ring with a newly joined node and informing all the nodes of its existence.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++>n.stabilize()
  x <span style=color:#f92672>=</span> successor.predecessor
  <span style=color:#66d9ef>if</span>(x is in between n and successor)
    successor <span style=color:#f92672>=</span> x
  successor.notify(n)
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++>n.notify(n1)
  <span style=color:#66d9ef>if</span>(predecessor is nil or n1 is in between predecessor and n)
    predecessor <span style=color:#f92672>=</span> n1
</code></pre></div><p>Another function, <strong>CheckPredecessor</strong> also runs periodically to verify the liveness of the predecessor. The time interval for CheckPredecessor is suggested to be 15 seconds by the paper.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++>n.check_predecessor()
  <span style=color:#66d9ef>if</span>(predecessor has failed)
    predecessor <span style=color:#f92672>=</span> nil
</code></pre></div><h2 id=implementation-in-golang>Implementation in Golang</h2><p><strong><a href=https://github.com/arush15june/chord-golang>Source Code on GitHub</a></strong></p><p>As explained above, a Chord Ring (or, network) consists of nodes constantly updating their finger table, stabilizing their position in the ring to let new nodes join, verifying the liveness of their predecessor, and looking up the location of keys using the finger tables. Thus creating a dynamically updating and decentralized network for looking up keys i.e a Distributed Hash Table.</p><p>I have implemented Chord in Golang, recreating the pseudocode in the paper. The concept of a virtual node is implemented in the form of independent threads running on different ports on the same system, this enables every local node to be accessed via the network. The nodes are created in a manner which allows Local Nodes to be directly contacted by Direct Method calls rather than unnecessarily sending RPC&rsquo;s over the network. RPC is implemented using Golang&rsquo;s internal gob encoding based RPC mechanism.</p><p>To enable the intermingling of local and remote nodes, a common interface VNodeProtocol is defined which is implemented by two different types of VNodes: LocalVNode and RemoteVNode. While the LocalVNode contains the logic for the Chord protocol, the RemoteVNode are just RPC Wrappers to contact LocalVNodes running on remote systems. VNodeProtocol allows the protocol to transparently handle both Remotely and Locally available nodes. Locally running worker threads contact each other using Direct Method calls, and calling the same methods via RPC for RemoteVNodes.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>      ---&gt; LocalVNode: Local Implementation of a VNode.
      |                Contains implementation of the Chord Protocol
      |
VNode.VNodeProtcol ---&gt; Generic Interface to the Chord Protocol.
      |
      |
      ---&gt; RemoteVNode: RPC Backed VNode which communicates to the RPC Server
                        (defined in `rpcserver.go`) which calls the remote
                        processes&#39; LocalVNode to fulfil the RPC.
</code></pre></div><p>The finger and successor tables are lists of VNodeProtocol objects, A hostname is wrapped as a RemoteVNode object to join a Chord ring, Each individual VNode on the machine is a LocalVNode in its own goroutine running the stabilization, finger fixing, and predecessor verification routines along with running an RPC server in the background.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// VNodeProtocol implements the Chord protocol on Vnodes.
</span><span style=color:#75715e>// Local VNodes can implement it via method calls.
</span><span style=color:#75715e>// Remote VNodes can use RPC to transparently work like Local VNodes.
</span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>VNodeProtocol</span> <span style=color:#66d9ef>interface</span> {
	<span style=color:#75715e>// FindSuccessors finds N successors of the VNode.
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>FindSuccessors</span>(<span style=color:#66d9ef>int</span>) ([]<span style=color:#a6e22e>VNodeProtocol</span>, <span style=color:#66d9ef>error</span>)

	<span style=color:#75715e>// FindSuccessor finds the successor for a Key.
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>FindSuccessor</span>(<span style=color:#66d9ef>uint64</span>) (<span style=color:#a6e22e>VNodeProtocol</span>, <span style=color:#66d9ef>error</span>)

	<span style=color:#75715e>// Notify notifies the VNode of its new predecessor.
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>Notify</span>(<span style=color:#a6e22e>VNodeProtocol</span>) <span style=color:#66d9ef>error</span>

	<span style=color:#75715e>// Ping sends a request to a VNode
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>Ping</span>() <span style=color:#66d9ef>error</span>

	<span style=color:#75715e>// CheckPredecessor checks the aliveness of VNode&#39;s predecessor.
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>CheckPredecessor</span>() <span style=color:#66d9ef>error</span>

	<span style=color:#75715e>// GetPredecessor returns the predecessor VNode.
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>GetPredecessor</span>() (<span style=color:#a6e22e>VNodeProtocol</span>, <span style=color:#66d9ef>error</span>)

	<span style=color:#75715e>// IsBetweenNodes
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>IsBetweenNodes</span>(<span style=color:#a6e22e>VNodeProtocol</span>, <span style=color:#a6e22e>VNodeProtocol</span>) <span style=color:#66d9ef>bool</span>

	<span style=color:#75715e>// ID returns the ID of the VNode.
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>ID</span>() <span style=color:#66d9ef>uint64</span>

	<span style=color:#75715e>// Hostname returns the hostname of the VNode.
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>Hostname</span>() <span style=color:#66d9ef>string</span>
}
</code></pre></div><h3 id=implementing-periodical-routines>Implementing periodical routines.</h3><p>The periodically running routines are each initialized as their own goroutine when the LocalVNode is first initialized along with their respective time intervals. An example of the Stabilization routine is given below. Where the Stabilize function is executed in a time interval between <code>[node.minStabilizeInterval, node.maxStabilizeInterval]</code>.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// Stabilize executes after certain time intervals to fix successors.
</span><span style=color:#75715e>// &gt; Each time node n runs Stabilize(), it asks its successor
</span><span style=color:#75715e>// &gt; for the successor’s predecessor p, and decides whether p
</span><span style=color:#75715e>// &gt; should be n’s successor instead. stabilize() notifies node
</span><span style=color:#75715e>// &gt; n’s successor of n’s existence, giving the successor the chance
</span><span style=color:#75715e>// &gt; to change its predecessor to n.
</span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>node</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>LocalVNode</span>) <span style=color:#a6e22e>Stabilize</span>() <span style=color:#66d9ef>error</span> {
	<span style=color:#a6e22e>logger</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;[%s, %d] Stabilizing VNode\n&#34;</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Hostname</span>(), <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>ID</span>())

	<span style=color:#a6e22e>verifySuccesorNode</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>successors</span>[<span style=color:#ae81ff>0</span>].<span style=color:#a6e22e>GetPredecessor</span>()
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>verifySuccesorNode</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>verifySuccesorNode</span>.<span style=color:#a6e22e>IsBetweenNodes</span>(<span style=color:#a6e22e>node</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>successors</span>[<span style=color:#ae81ff>0</span>]) {
		<span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>successors</span>[<span style=color:#ae81ff>0</span>] = <span style=color:#a6e22e>verifySuccesorNode</span>
		<span style=color:#a6e22e>logger</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;[%s, %d] Updated successor: %s\n&#34;</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Hostname</span>(), <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>ID</span>(), <span style=color:#a6e22e>verifySuccesorNode</span>.<span style=color:#a6e22e>Hostname</span>())
	}

	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>successors</span>[<span style=color:#ae81ff>0</span>].<span style=color:#a6e22e>ID</span>() <span style=color:#f92672>!=</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>ID</span>() {
		<span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>successors</span>[<span style=color:#ae81ff>0</span>].<span style=color:#a6e22e>Notify</span>(<span style=color:#a6e22e>node</span>)
		<span style=color:#a6e22e>logger</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;[%s, %d] Notified %s of VNode.\n&#34;</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Hostname</span>(), <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>ID</span>(), <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>successors</span>[<span style=color:#ae81ff>0</span>].<span style=color:#a6e22e>Hostname</span>())
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
	}

	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
}

<span style=color:#75715e>// StabilizeRoutine runs Stabilize() periodically by choosing an interval
</span><span style=color:#75715e>// between minStabilizeInterval and maxStabilizeInterval.
</span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>node</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>LocalVNode</span>) <span style=color:#a6e22e>StabilizeRoutine</span>() <span style=color:#66d9ef>error</span> {
	<span style=color:#a6e22e>exit</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>false</span>

	<span style=color:#66d9ef>for</span> {
		<span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Stabilize</span>()

		<span style=color:#a6e22e>interval</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>Util</span>.<span style=color:#a6e22e>GetRandomBetween</span>(<span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>minStabilizeInterval</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>maxStabilizeInterval</span>)
		<span style=color:#a6e22e>timer</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>NewTimer</span>(<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Duration</span>(<span style=color:#a6e22e>interval</span>) <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>)
		<span style=color:#66d9ef>select</span> {
		<span style=color:#66d9ef>case</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>timer</span>.<span style=color:#a6e22e>C</span>:
		<span style=color:#66d9ef>case</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>stopStabilizeChan</span>:
			<span style=color:#a6e22e>exit</span> = <span style=color:#66d9ef>true</span>
		}
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>exit</span> {
			<span style=color:#66d9ef>break</span>
		}
	}
	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
}

<span style=color:#75715e>// GetRandomBetween returns a random integer value between low and high.
</span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>GetRandomBetween</span>(<span style=color:#a6e22e>low</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>high</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span> {
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>rand</span>.<span style=color:#a6e22e>Intn</span>(<span style=color:#a6e22e>high</span><span style=color:#f92672>-</span><span style=color:#a6e22e>low</span>) <span style=color:#f92672>+</span> <span style=color:#a6e22e>low</span>
}

</code></pre></div><h3 id=hostnames-and-rpc>Hostnames and RPC</h3><p>RPC is implemented using the net/rpc package which internally serializes structures and transmits them over the network. A TCP RPC Server is kept running by each LocalVNode for remote nodes to contact them.</p><p>The RPC Server can take in the hostnames for running the server in various forms. It depends on the input to net.Listen (as can be seen in the implementation of InitServer).</p><p>The user can pass in a hostname like &ldquo;192.168.1.116:8000&rdquo; which will bind port 8000 on the interface with the IP 192.168.1.116 on the physical system. If the user wants a random port to be allocated by the kernel itself, they can supply a hostname address like &ldquo;192.168.1.116:&rdquo; binding a random port as supplied by the kernel for the RPC server. This is reflected in the Hostname field of the LocalVNode and is transmitted to RemoteVNode in RPC arguments and results. Thus it is important to consider the hostname format. A hostname like &ldquo;[::]:0&rdquo; will bind a random port on 0.0.0.0 but will break the system when passed onto a remote VNode via RPC.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// InitServer starts Chord Protocol TCP-RPC server on Hostname:Port.
</span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>InitServer</span>(<span style=color:#a6e22e>rpcInstance</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>ChordTCPRPCServer</span>) <span style=color:#66d9ef>error</span> {
	<span style=color:#a6e22e>rpc</span>.<span style=color:#a6e22e>Register</span>(<span style=color:#a6e22e>rpcInstance</span>)
	<span style=color:#a6e22e>l</span>, <span style=color:#a6e22e>e</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>net</span>.<span style=color:#a6e22e>Listen</span>(<span style=color:#e6db74>&#34;tcp&#34;</span>, <span style=color:#a6e22e>rpcInstance</span>.<span style=color:#a6e22e>Hostname</span>)
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>e</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>New</span>(<span style=color:#e6db74>&#34;failed to start Listen server&#34;</span>)
	}

	<span style=color:#75715e>// Reset address as acquired by Listener.
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>address</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>Addr</span>().<span style=color:#a6e22e>String</span>()
	<span style=color:#a6e22e>rpcInstance</span>.<span style=color:#a6e22e>Hostname</span> = <span style=color:#a6e22e>address</span>

	<span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>() {
		<span style=color:#66d9ef>for</span> {
			<span style=color:#a6e22e>conn</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>Accept</span>()
			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
				<span style=color:#66d9ef>continue</span>
			}
			<span style=color:#66d9ef>go</span> <span style=color:#a6e22e>rpc</span>.<span style=color:#a6e22e>ServeConn</span>(<span style=color:#a6e22e>conn</span>)
		}
	}()

	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
}
</code></pre></div><h3 id=http-server-for-key-lookup>HTTP Server For Key Lookup</h3><p>A Single HTTP Server is hosted which uses one of the globally accessible worker nodes to look up a key passed in as form data in an HTTP POST request.</p><p>The <code>/lookup</code> endpoint returns the location of the node where the key will be stored.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ curl -X POST localhost:8090/lookup -d <span style=color:#e6db74>&#34;TestKey&#34;</span>
127.0.0.1:8000
</code></pre></div><h3 id=some-examples>Some examples</h3><p>The project doesn&rsquo;t have any external dependencies. I developed the project using Go 1.12 on Windows 10 1909.</p><ul><li>Build the program.</li></ul><pre><code>  go build
</code></pre><ul><li>Run a single worker thread on <strong>127.0.0.1:8000</strong>.</li></ul><pre><code>  ./src -host 127.0.0.1:8000
</code></pre><ul><li>Connect to a remote host.</li></ul><pre><code>  ./src -mode join -httpport 8091 -host 127.0.0.1:8001 -rhost 127.0.0.1:8000
</code></pre><ul><li>Run 8 Local Worker Threads on Randomly Assigned Ports <strong>(0.0.0.0:0)</strong>.</li></ul><pre><code>  ./src -workers 8
</code></pre><h2 id=conclusion>Conclusion</h2><p>The Chord protocol is implemented, however, there is still polishing to be done for improving, configuration of the workers (possibly a YAML file to define them?). This is one of the firsts for me where I went from reading a paper to implementing it and many open source implementations helped me throughout this process: <a href=https://github.com/armon/go-chord>armon/go-chord</a>, <a href=https://github.com/cbocovic/chord>cbocovic/chord</a> and <a href=https://github.com/yuma-m/pychord>yuma-m/pychord</a>.</p><h2 id=references>References</h2><ul><li><a href=https://pdos.csail.mit.edu/papers/chord:sigcomm01/chord_sigcomm.pdf>Original Research Paper for Chord</a></li></ul></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read other posts</span><hr></div><div class=pagination__buttons><span class="button previous"><a href=/posts/2020-04-30-binrec/><span class=button__icon>←</span>
<span class=button__text>Papers: BinRec: Dynamic Binary Lifting and Recompilation</span></a></span>
<span class="button next"><a href=/posts/2019-24-11-hacking-qatar/><span class=button__text>Bits & Signals: Qatar International Cybersecurity Competition</span>
<span class=button__icon>→</span></a></span></div></div></div></div><footer class=footer><div class=footer__inner><div class="copyright copyright--user"><span>Aarush Ahuja :: 2020</span>
<span>:: Theme made by <a href=https://twitter.com/panr>panr</a></span></div></div></footer><script src=/assets/main.js></script><script src=/assets/prism.js></script></div></body></html>