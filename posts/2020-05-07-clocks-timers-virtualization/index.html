<!doctype html><html lang=en><head><title>Clocks, Timers and Virtualization :: silly onions — Opinionated articles</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta name=description content="Clocks and Timers  A system might have two kinds of clocks available to use in the system, a Wall-Clock Timer and a Monotonic Clock.
  Wall-Clock Timer
This represents the time as it will be on a wall-clock. Usually, wall-clock time is counted as the number of time units since January 1, 1970 00:00:00 UTC or EPOCH. This clock can go forward or backwards in time as desired by synchronization algorithms (NTP) or the user to represent the current time, due to this reason they are not recommended for measuring durations."><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=/posts/2020-05-07-clocks-timers-virtualization/><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-99588570-3','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><link rel=stylesheet href=/assets/style.css><link rel=stylesheet href=/assets/red.css><link rel=apple-touch-icon-precomposed sizes=144x144 href=/img/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/img/favicon/red.png><meta name=twitter:card content="summary"><meta name=twitter:title content="Clocks, Timers and Virtualization :: silly onions — Opinionated articles"><meta name=twitter:description content="Clocks and Timers  A system might have two kinds of clocks available to use in the system, a Wall-Clock Timer and a Monotonic Clock.
  Wall-Clock Timer
This represents the time as it will be on a wall-clock. Usually, wall-clock time is counted as the number of time units since January 1, 1970 00:00:00 UTC or EPOCH. This clock can go forward or backwards in time as desired by synchronization algorithms (NTP) or the user to represent the current time, due to this reason they are not recommended for measuring durations."><meta name=twitter:site content="/"><meta name=twitter:creator content><meta name=twitter:image content><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="Clocks, Timers and Virtualization :: silly onions — Opinionated articles"><meta property="og:description" content="Clocks and Timers  A system might have two kinds of clocks available to use in the system, a Wall-Clock Timer and a Monotonic Clock.
  Wall-Clock Timer
This represents the time as it will be on a wall-clock. Usually, wall-clock time is counted as the number of time units since January 1, 1970 00:00:00 UTC or EPOCH. This clock can go forward or backwards in time as desired by synchronization algorithms (NTP) or the user to represent the current time, due to this reason they are not recommended for measuring durations."><meta property="og:url" content="/posts/2020-05-07-clocks-timers-virtualization/"><meta property="og:site_name" content="Clocks, Timers and Virtualization"><meta property="og:image" content><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><meta property="article:section" content="article"><meta property="article:published_time" content="2020-05-12 00:00:00 +0000 UTC"></head><body><div class="container center"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>sillyonions</div></a></div><div class=menu-trigger>menu</div></div><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/about>About</a></li><li><a href=/books>Books</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/about>About</a></li><li><a href=/books>Books</a></li></ul></nav></header><div class=content><div class=post><h1 class=post-title><a href=/posts/2020-05-07-clocks-timers-virtualization/>Clocks, Timers and Virtualization</a></h1><div class=post-meta><span class=post-date>2020-05-12</span></div><span class=post-tags>#<a href=/tags/virtualization/>virtualization</a>&nbsp;
#<a href=/tags/clocks/>clocks</a>&nbsp;</span><div class=post-content><h1 id=clocks-and-timers>Clocks and Timers</h1><hr><p>A system might have two kinds of clocks available to use in the system, a Wall-Clock Timer and a Monotonic Clock.</p><ul><li><p>Wall-Clock Timer</p><p>This represents the time as it will be on a wall-clock. Usually, wall-clock time is counted as the number of time units since January 1, 1970 00:00:00 UTC or <code>EPOCH</code>. This clock can go forward or backwards in time as desired by synchronization algorithms (NTP) or the user to represent the current time, due to this reason they are not recommended for measuring durations. CLOCK_REALTIME is a Wall-Clock timer in Linux.</p></li><li><p>Monotonic Clock</p><p>A Monotonic Clock is a constantly increasing timer which guarantees that it will never go backwards in time. The frequency rate of the timer might not be constant and be adjusted by synchronization algorithms, which means that one measured second might actually be a different amount of time from another measured second. CLOCK_MONOTONIC is a Monotonic Clock in Linux. The absolute value of the timer is not useful as it based on counting time from an arbitrary point in the past, but rather monotonic clocks are useful for measuring durations with high certainty. Monotonic Clocks often offer a higher resolution than Wall-Clock Timers.</p></li></ul><img src=/img/hardware_clock.png alt="Hardware Clock" class=center><p>Hardware Clocks at an abstract level comprise of an oscillator set to a frequency which could be fixed or set by the operating system at boot. There are various types of hardware timers available in a system: Programmable Interval Timer (PIT), CMOS RTC, per-processor advance programmable interrupt controller (APIC), Advanced Configuration and Power Interface (ACPI) Timer, Timestamp Counter, High Precision Event Timer (HPET).</p><p>Big words, will be discussed in this section.</p><ul><li><p>Tick Counting</p><p>It involves setting up a hardware device to send &ldquo;ticks&rdquo; at a fixed interval known to the OS, the OS keeps track of the time based on the received ticks. Example: A fixed interval of 100 times per second can provide a minimum resolution of 0.01s. The hardware device in this case can be the Programmable Interval Timer.</p></li><li><p>Tickless Counting</p><p>It involves a hardware counter keeping the count of time units passed since system boot. The operating system only reads the counter when required. The CPU does not spend any time maintaining this timer and provides higher resolution. The X86 Timestamp Counter (TSC) is a Tickless counter which can be read using the <code>RDTSC</code> or <code>RDTSCP</code> instruction.</p></li></ul><p>Initially, the computer reads latest time from the battery-powered CMOS Real Time Clock to initialize other clocks in the system.</p><h2 id=hardware-timekeeping-devices>Hardware Timekeeping Devices</h2><ul><li><p><a href=https://en.wikipedia.org/wiki/Programmable_interval_timer>PIT</a></p><p>A hardware device which sends a signal when a certain programmed count is reached. Depending on one-shot or periodic modes, it might send the signal only once or keep sending it periodically. Oldschool timekeeping device, oscillates at 1.193182 MHz, 16 bit counter. It consists of three different timers used historically for different purposes like RAM Refresh, PC Speaker Tone Generation, etc. The Intel 8253 is a classic example of a PIT.</p></li><li><p>CMOS RTC</p><p>It&rsquo;s a battery-backed clock which stores the wall-clock time to the nearest second. Also, CMOS RTC contains a timer which does tick counting by generating interrupts in the frequency range of 2Hz-8192Hz. It can also provide per second interrupts, imitating a real wall-clock.</p></li><li><p>Local APIC Timer</p><p>A per-processor integrated onto the processor itself (whereas the PIT is an external device). It oscillates at the same frequency as the CPU which can vary from machine to machine. Similar to the PIT timer, it can generate interrupts to the CPU in One-Shot or Periodic modes with time intervals configured by the operating system/user. The OS sets a current count on the APIC timer and the circuit counts down until zero is hit. Depending on the bus frequency of the system, the CPU decrements this value. In new CPUs, a TSC-Deadline mode interacts with the CPU TSC and generates an interrupt when a certain TSC value is hit. It is also unreliable as there isn&rsquo;t a reliable way to determine CPU frequency.</p></li><li><p>ACPI Timer</p><p>Required as per the ACPI spec, A 24-bit timer oscillating at three times the PIT frequency used for power management in the system.</p></li><li><p><a href=https://en.wikipedia.org/wiki/Time_Stamp_Counter>TSC</a></p><p>A tickless counter available on modern x86 Processors which provides apparent time in the system. It is the highest resolution clock available on the system. <strong>It is a 64-bit timer oscillating at the CPUs frequency and counts CPU cycles</strong>. Unlike the PIT or APIC, it does not generate any interrupts. Instead, it is read when required. <strong>A Model-specific Register exposes the TSC</strong> which is accessible in both user mode and kernel mode by default.</p><p><strong>In newer CPUs, a constant rate TSC is available which oscillates independently of the current CPU frequency</strong>, counting the passage of time rather than CPU clock cycles.</p><p><strong>The TSC is known to be unreliable due to rate of tick flaws, multi-core issues, variable CPU frequency etc</strong>. In multi-core systems, the TSC might not be exactly synchronized across each CPU, which can lead to incorrect measurements [5]. Due to out of order execution, the CPU might execute RDTSC earlier than expected. This issue can be solved by serializing execution and running the CPUID instruction before the RDTSC instruction.</p><p><strong>Due to its high resolution, it is used by side-channel exploitation techniques like Meltdown and Spectre</strong> to measure instruction execution times accurately. [5] highlights various issues with the TSC.</p></li><li><p>HPET</p><p>It is an external hardware timer available on some newer systems. An HPET could be 32-or-64bit and can provider higher resolution than the PIT or CMOS RTC. Due to lax specifications, HPET implementations are not guaranteed to have a high resolution or low drift. It is designed to replace the PIT and CMOS in newer systems.</p></li></ul><h1 id=virtualized-timekeeping>Virtualized Timekeeping</h1><hr><p>Hypervisors like VMWare ESXi or Workstation virtualize all the above described timers for the virtual machine, though there might be trade-offs involved.</p><ul><li>The virtualized PIT provides all the modes and three channels of the PIT timer, however, the sound generation timer might not correctly generate the frequency or duration for the requested sound. The virtualized PIT might not be able to generate high frequencies of requested interrupts, ex. 1000hz default on many Linux distros.</li><li>The virtualized CMOS RTC in VMWare emulates all functionalities (TOD, etc) of the RTC implemented as an offset of the host operating systems software clock. If the host clock&rsquo;s time is change, the guest&rsquo;s clock might also be changed.
In some systems, this can trigger an unexpected feedback loop where if the virtual machine is the time server for the host, they might go back and forth changing their clocks trying to synchronize with each other.</li><li>The virtualized APIC timer, ACPI timer and the TSC both present apparent time matching each other.</li></ul><p>I have not been able to find similar implementation information for KVM or other hypervisors.</p><h3 id=tsc-virtualization>TSC Virtualization</h3><h3 id=kvm-5>KVM [5]</h3><p>In both Intel VT-x and AMD SVM, the TSC can be fully virtualized by trapping the <code>RDTSC</code>, <code>RDMSR</code>, <code>WRMSR</code> and <code>RDTSCP</code> instructions [5]. Also, it is possible to pass through the host TSC to the virtual machine. Both trapping and passthrough are implemented in KVM [5].</p><p>Issues surrounding TSC synchronization arise from the fact that the CPUs frequency can be altered by the system for different reasons. This can change the rate of TSC per-processor. The Inter-CPU drift is even further amplified in the case of inter-socket drift in the case of multi-socket systems [7].</p><p>A program reading the TSC from one core might get a different incorrect value of the TSC when reading it from another core. To mitigate this issue solutions include reading the processor ID using the CPUID instruction first and indexing into the TSC array to fetch the specific processors TSC or using the RDTSCP instruction which fetches the processor ID and the TSC value.</p><p>Apart from solutions in software, newer x86 CPUs also include an invariant TSC which operates independently of the CPUs current frequency, guaranteeing the rate of the TSC. This can even be used a wall-clock source.</p><h3 id=vmware-1>VMWare [1]</h3><p>VMWare provides an exactly synchronized view of the TSC to the virtual machine [1], either backed by the physical TSC itself, or an emulated virtual TSC if the physical TSC turns out to be unsynchronized at the trade-off of increasing execution times of the <code>RDTSC</code> instruction.</p><h3 id=hyper-v-3>Hyper-V [3]</h3><p>Hyper-V, similar to VMWare&rsquo;s products, provides virtualized timer services based on a reference time source in the host. According to the Top-Level Functional Specifications (v6.0b), a per-virtual machine reference counter, four synthetic timers per-vCPU, one virtualized APIC timer per vCPU, two timer assists, and a partition reference time enlightenment based on support for an invariant TSC is available to the guest.</p><ul><li>Reference Counter: A strictly monotonic constant rate timer seen by all virtual processors unaffected by processor or bus frequency. It runs at the same rate for all VMs, but reference counters between VM are not synchronized (no same absolute value). This counter counts as long as at least one vCPU in the VM is not suspended. This timer is exposed to the guest via a Model-specific Register (MSR).</li><li>Synthetic Timers: Virtualized interrupt-generataing one-shot or periodic timers. These timers are exposes to the guest via Model-specific Registers.</li><li>Partition Reference Time Enlightenment: An invariant time source for the virtual machine which does not require an intercept into the hypervisor. This is available only if a constant rate TSC is available on the host, as is the case with newer CPUs.
The invariant TSC solves the issues surrounding the older TSC implementation as its frequency remains constant irrespective of the CPU frequency, as was the case with older TSC implementation. This enlightened reference counter is exposed as a virtual reference TSC page in the guest physical addresses.</li></ul><img src=/img/hyperv_clocksource.png alt="HyperV Clocksource" class=center><p>In the WSL2 Kernel, the only available clocksource is based on this partition wide TSC enlightened clocksource.</p><h3 id=virtualbox-8>VirtualBox [8]</h3><p>By default VirtualBox exposes the time sources available to the guest synchronized to the host&rsquo;s monotonic clock. However, there is also a special configuration available to make the virtual guest TSC reflect the actual time spent by the CPU executing the guest. Depending on the hardware TSC, it might be unreliable to use the TSC for measurements.</p><h1 id=clocks-in-linux>Clocks in Linux</h1><hr><p>Latest linux kernels exposes the clocks described in the above sections via the Clocksource framework to expose different clock sources via a generic API [4]. In a bare-metal Linux system, the clocksources might consist of the TSC, ACPI Power Management timer, the HPET etc.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#75715e># Enumerate your available clocksources.</span>
$ cat /sys/devices/system/clocksource/clocksource0/available_clocksource
tsc hpet acpi_pm

<span style=color:#75715e># Get current clocksource</span>
$ cat /sys/devices/system/clocksource/clocksource0/current_clocksource
tsc
</code></pre></div><p>User-mode time related functions like <code>gettimeofday</code>, <code>clock_gettime</code> are backed by these clock sources. Using the <code>clock_sources</code> system-call, various different types of clocks in the systems can be accessed by a user-mode program.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;time.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>clock_getres</span>(clockid_t clk_id, <span style=color:#66d9ef>struct</span> timespec <span style=color:#f92672>*</span>res);
<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>clock_gettime</span>(clockid_t clk_id, <span style=color:#66d9ef>struct</span> timespec <span style=color:#f92672>*</span>tp);
<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>clock_settime</span>(clockid_t clk_id, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>struct</span> timespec <span style=color:#f92672>*</span>tp);

Time system calls in Linux.
</code></pre></div><p>Available Clock IDs could include:</p><ul><li><code>CLOCK_REALTIME</code></li><li><code>CLOCK_REALTIME_COARSE</code></li><li><code>CLOCK_MONOTONIC</code></li><li><code>CLOCK_MONOTONIC_COARSE</code></li><li><code>CLOCK_MONOTONIC_RAW</code></li><li><code>CLOCK_BOOTTIME</code></li><li><code>CLOCK_PROCESS_CPUTIME_ID</code></li><li><code>CLOCK_THREAD_CPUTIME_ID</code></li></ul><p>Run <code>man clock_gettime</code> in your favourite shell to learn more about <code>clock_gettime</code>. The current clocksource is used as the basis for all these timers.</p><img src=/img/clock_gettime_man.png alt="clock_gettime manpage" class=center><p>As their name suggests, these different clock implementation has different characteristics. The REALTIME clocks give wall-clock time while the MONOTONIC clocks give apparent time.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;time.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/time.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span> <span style=color:#f92672>**</span>argv)
{
    <span style=color:#66d9ef>struct</span> timespec elapsed_from_boot;

    clock_gettime(CLOCK_MONOTONIC, <span style=color:#f92672>&amp;</span>elapsed_from_boot);

    printf(<span style=color:#e6db74>&#34;%d - seconds elapsed from boot</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, elapsed_from_boot.tv_sec);

    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}

<span style=color:#75715e># Reading the system monotonic clock in C.
</span></code></pre></div><h1 id=clocks-in-windows>Clocks in Windows</h1><hr><h3 id=system-time>System Time</h3><p>For the current time-of-day and date, Windows uses the CMOS RTC at boot to initialize the <em>System Time</em> [10]. This time can be obtained by using the <a href="https://docs.microsoft.com/en-us/windows/win32/api/sysinfoapi/nf-sysinfoapi-getsystemtimeasfiletime?redirectedfrom=MSDN"><code>GetSystemTimeAsFileTime</code></a> function. System Time in windows can be adjusted by the user.</p><h3 id=interrupt-time>Interrupt Time</h3><p>A monotonic clock, <em>Interrupt Time</em>[11] is maintained by windows which is updated at 100ns intervals. This timer cannot be changed by the user and is a tick counter (updated via interrupts). The <code>QueryInterruptTime</code> and <code>QueryInterruptTimePrecise</code> can be used to access the Interrupt Time with a resolution ranging from 0.5ms to 15.625ms.</p><h3 id=high-resolution-timestamps>High-Resolution Timestamps</h3><p>To acquire higher-resolution timestamps in Windows[9], The <code>QueryPerformanceCounter</code> and <code>QueryPerformanceFrequency</code> can be combined to create a timer based on a high-resolution performance counter. <code>QueryPerformanceFrequency</code> returns the frequency at which counting is happening. <code>QueryPerformanceCounter</code> returns the counter value, dividing the difference between two counter values with the counter frequency can be used to measure duration values at a high resolution. This is the highest resolution timer available in windows. The API itself is not based on reading a performance counter, but rather is an abstraction on the available timers in the system, like the TSC or HPET.</p><p>Older versions of Windows implemented the high-resolution performance counter using either the non-invariant TSC which could cause synchronization problems across cores (in XP and 2000) or the HPET (in Vista). Starting from Windows 7, the performance counter is implemented via the constant rate TSC (using the <code>RDTSC</code>/<code>RDTSCP</code> instruction). Microsoft does not recommend using <code>RDTSC</code>/<code>RDTSCP</code> due to issues surrounding non-invariant TSCs and to leverage the abstraction and consistency provided by <code>QueryPerformanceCounter</code>.</p><h3 id=windows-time>Windows Time</h3><p>A low-resolution timer <em>Windows Time</em>[12] is also available which counts the number of milliseconds elapsed since boot. It is accessible via the <code>GetTick</code> and <code>GetTick64</code> function. It is primarily present for backwards compatibility with 16-bit Windows applications.</p><h1 id=timers-used-by-various-languages>Timers used by various languages</h1><hr><p>There are so many timers available in a system! PIT, HPET, RTC, APIC, ACPI, TSC! Wall Clocks, Monotonic Clocks! Let&rsquo;s take a look at which timer is used by the standard library of various languages.</p><h3 id=golang>Golang</h3><p>The <code>time</code> module[13] in Go provides access to both a wall-clock reading and monotonic clock reading. Time-telling operations use the wall-clock reading and time-measuring operations use the monotonic clock reading.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// time.Now() gives a monotonic clock reading!
</span><span style=color:#75715e></span><span style=color:#a6e22e>start</span> = <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Now</span>()
<span style=color:#a6e22e>do_something</span>()
<span style=color:#a6e22e>end</span> = <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Now</span>()

<span style=color:#75715e>// Uses monotonic clock reading as end.Sub(start) is a time-measuring operation.
</span><span style=color:#75715e></span><span style=color:#a6e22e>elapsed</span> = <span style=color:#a6e22e>end</span>.<span style=color:#a6e22e>Sub</span>(<span style=color:#a6e22e>start</span>)

<span style=color:#75715e>// Falls back to wall-clock reading as end.AddDate(1, 1, 1) is a time-telling operation.
</span><span style=color:#75715e></span><span style=color:#a6e22e>next_year</span> = <span style=color:#a6e22e>end</span>.<span style=color:#a6e22e>AddDate</span>(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>)

<span style=color:#75715e>// Check time godoc for more information!
</span><span style=color:#75715e>// https://golang.org/pkg/time/
</span></code></pre></div><p>However, the Golang docs does not specify which APIs does Golang use internally for retrieving wall-clock or monotonic time.</p><p>The <code>time</code> modules <a href=https://github.com/golang/go/blob/master/src/time/time.go#L1051>source code</a> reveals <code>time.Now</code> on two runtime specific functions <code>now</code> for the wall-clock and <code>runtimeNano</code> for the monotonic clock. These functions are individually implemented for each runtime supported by Golang.</p><img src=/img/go_time_common.png alt="Go Time Common" class=center><p><a href=https://github.com/golang/go/blob/master/src/time/time.go#L1051>Source Code</a></p><p>The Windows Golang runtime uses <code>QueryPerformanceCounter</code> API to implement <code>runtimeNano</code> for monotonic clock-reading (which in turn uses the invariant TSC) and the <code>GetSystemTimeAsFileTime</code> API to implement <code>now()</code> for wall-clock time reading.</p><img src=/img/go_time_windows.png alt="Go Time Windows" class=center><p><a href=https://github.com/golang/go/blob/master/src/runtime/os_windows.go#L452>Source Code</a></p><p>On the Linux and AMD64 runtime, <code>clock_gettime</code> is used to fetch both wall-clock reading and monotonic clock reading, with <code>gettimeofday</code> as the fallback function. <code>CLOCK_REALTIME</code> is used for wall-clock readings and <code>CLOCK_MONOTNIC</code> for the monotonic-clock readings. The actual hardware device is decided by the current clocksource used by the system, which in most cases should either be the HPET or the invariant TSC. Source code for <a href=https://github.com/golang/go/blob/master/src/runtime/sys_linux_amd64.s#L268>monotonic clock</a> and <a href=https://github.com/golang/go/blob/master/src/runtime/sys_linux_amd64.s#L268>wall-clock</a>.</p><h3 id=rust>Rust</h3><p>Rust&rsquo;s documentation conveniently documents the source of time used by the timers present in its standard library.</p><p>The monotonic clock in Rust <code>std::time::Instant</code>[14] uses <code>QueryPerformanceCounter</code> on Windows and <code>CLOCK_MONOTONIC</code> on Linux.</p><img src=/img/rust_instant.png alt="Rust Monotonic Clock" class=center><p>Wall-clock time is fetched using <code>std::time::SystemTime</code>[15] which uses <code>GetSystemTimeAsFileTime</code> on Windows and <code>CLOCK_REALTIME</code> on Linux.</p><img src=/img/rust_system.png alt="Rust System Clock" class=center><h3 id=python-38>Python 3.8</h3><p>Python provides <code>time.get_clock_info</code> in its time library to get implementation-specific information of the five clocks exposed by the <code>time</code> library [16]. We focus on three: <code>monotonic</code>, <code>perf_counter</code> and <code>time</code>.</p><img src=/img/python_clocks.png alt="Python Clocks" class=center><p>Clock implementations in Python 3.8.2</p><h3 id=monotonichttpsdocspythonorg3librarytimehtmltimemonotonic><a href=https://docs.python.org/3/library/time.html#time.monotonic><code>monotonic</code></a></h3><p>It returns the value of a monotonic clock, which might not necessarily be the highest resolution clock available in the system. There are two functions <a href=https://docs.python.org/3/library/time.html#time.perf_counter><code>time.monotonic</code></a> and <a href=https://docs.python.org/3/library/time.html#time.monotonic_ns><code>time.monotonic_ns</code></a> available to access this clock which returns the value of the clock as fractional seconds.</p><p>On Windows, this clock is implemented using <code>GetTickCount64</code> which is a low-resolution monotonic clock (<a href=https://docs.microsoft.com/en-us/windows/win32/sysinfo/windows-time>Windows Time</a> as discussed above).</p><p>On Linux, this clock is implemented using <code>CLOCK_MONOTONIC</code> .</p><h3 id=perf_counterhttpsdocspythonorg3librarytimehtmltimeperf_counter><a href=https://docs.python.org/3/library/time.html#time.perf_counter><code>perf_counter</code></a></h3><p>It returns the value of a monotonic clock which is the highest resolution clock available in the system. There are two functions <a href=https://docs.python.org/3/library/time.html#time.perf_counter><code>time.perf_counter</code></a> and <a href=https://docs.python.org/3/library/time.html#time.perf_counter_ns><code>time.perf_counter_ns</code></a> available to access this clock which returns the value of the clock as fractional seconds.</p><p>On Windows, this clock is implemented using <code>QueryPerformanceCounter</code> which in turn uses the invariant TSC internally.</p><h3 id=timehttpsdocspythonorg3librarytimehtmltimetime><a href=https://docs.python.org/3/library/time.html#time.time><code>time</code></a></h3><p>It returns the value of a wall clock as a floating-point number which represents the time since epoch in seconds.</p><p>On Windows, this is implemented using <code>GetSystemTimeAsFileTime</code> which is the <em>System Time</em> as discussed in the previous sections.</p><p>On Linux, this is implemented using <code>CLOCK_REALTIME</code> .</p><h3 id=nodejs>Node.js</h3><p>On <a href=https://github.com/nodejs/node/blob/master/deps/v8/src/base/platform/time.cc#L575>Windows</a>, Node.js <code>QueryPerformanceCounter</code> for its monotonic clock with fall-backs to HPET or ACPI PM timer in case an invariant TSC is not present and <code>CLOCK_MONOTONIC</code> on Linux. It uses <code>GetSystemTimeAsFileTime</code> for wall-clock time readings on Windows.</p><h1 id=references>References</h1><ol><li><a href=https://www.vmware.com/content/dam/digitalmarketing/vmware/en/pdf/techpaper/Timekeeping-In-VirtualMachines.pdf>Timekeeping in VMWare Virtual Machines</a></li><li><a href=https://wiki.osdev.org/Main_Page>Clocks, Timers and Counters</a></li><li><a href=https://github.com/MicrosoftDocs/Virtualization-Documentation/raw/master/tlfs/Hypervisor%20Top%20Level%20Functional%20Specification%20v6.0b.pdf>Hypervisor Top-Level Functional Specfiications</a></li><li><a href=https://0xax.gitbooks.io/linux-insides/content/Timers/linux-timers-1.html>Timers and time management in the Linux Kernel</a></li><li><a href=https://www.kernel.org/doc/Documentation/virtual/kvm/timekeeping.txt>Linux Kernel Timekeeping</a></li><li><a href=http://btorpey.github.io/blog/2014/02/18/clock-sources-in-linux/>Measuring Latency in Linux</a></li><li><a href=https://www.linux-kvm.org/images/6/6a/2010-forum-time-keeping.pdf>A Quest Against Time</a></li><li><a href=https://www.virtualbox.org/manual/ch09.html#fine-tune-timers>VirtualBox Advanced Topics: Fine-tuning timers</a></li><li><a href=https://docs.microsoft.com/en-us/windows/win32/sysinfo/acquiring-high-resolution-time-stamps>Acquiring high-resolution time stamps</a></li><li><a href=https://docs.microsoft.com/en-us/windows/win32/sysinfo/system-time>System Time</a></li><li><a href=https://docs.microsoft.com/en-us/windows/win32/sysinfo/interrupt-time>Interrupt Time</a></li><li><a href=https://docs.microsoft.com/en-us/windows/win32/sysinfo/windows-time>Windows Time</a></li><li><a href=https://golang.org/pkg/time/>time - Golang</a></li><li><a href=https://doc.rust-lang.org/std/time/struct.Instant.html>std::time::Instant</a></li><li><a href=https://doc.rust-lang.org/std/time/struct.SystemTime.html>std::time::SystemTime</a></li><li><a href=https://docs.python.org/3/library/time.html#time.get_clock_info>time.get_clock_info</a></li></ol><h1 id=todo>TODO</h1><ul><li><a href=http://btorpey.github.io/blog/2014/02/18/clock-sources-in-linux/>Measuring clock resolution.</a></li><li>Dive into <code>hyperv_clocksource_tsc_page</code> in WSL2 and measure clock resolution.</li></ul></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read other posts</span><hr></div><div class=pagination__buttons><span class="button next"><a href=/posts/2020-04-30-binrec/><span class=button__text>Papers: BinRec: Dynamic Binary Lifting and Recompilation</span>
<span class=button__icon>→</span></a></span></div></div><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"arush15june-github-io"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></div><footer class=footer><div class=footer__inner><div class="copyright copyright--user"><span>Aarush Ahuja :: 2020</span>
<span>:: Theme made by <a href=https://twitter.com/panr>panr</a></span></div></div></footer><script src=/assets/main.js></script><script src=/assets/prism.js></script></div></body></html>